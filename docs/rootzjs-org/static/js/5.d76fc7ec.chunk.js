(this["webpackJsonprootzjs-org"]=this["webpackJsonprootzjs-org"]||[]).push([[5],{144:function(e,t,n){"use strict";n.d(t,"a",(function(){return a}));var o=n(7),a=Object(o.y)((function(e){return{link:{padding:"1px 4px",fontWeight:"bold",color:e.text[10],textDecoration:"none",backgroundColor:Object(o.x)(e.palette.secondary.main,.25),borderBottom:"solid 2px ".concat(e.palette.secondary.main)},button:{fontSize:20,display:"flex",cursor:"pointer",flexDirection:"column",color:e.text["00"],textTransform:"capitalize",padding:e.isMobile?"15px 25px":"15px 50px",margin:e.isMobile?"25px 0 120px":"25px 0 50px",backgroundColor:Object(o.x)(e.palette.secondary.main,.25),"&:hover":{backgroundColor:Object(o.x)(e.palette.secondary.main,.4)}},btnSubLabel:{fontSize:15,color:e.text[30]},buttonContainer:{display:"flex",justifyContent:"space-between"},btnContentWrapper:{display:"flex","& svg":{margin:3}},noteContainer:{fontSize:17,borderRadius:3,margin:"40px 0",padding:"10px 20px",borderLeft:"solid 7px #E4A800",backgroundColor:Object(o.x)("#E4A800",.25)},noteContainerAttention:{fontSize:17,borderRadius:3,margin:"40px 0",padding:"10px 20px",borderLeft:"solid 7px #E44100",backgroundColor:Object(o.x)("#E44100",.25)},noteContainerInfo:{fontSize:17,borderRadius:3,margin:"40px 0",padding:"10px 20px",borderLeft:"solid 7px #00BDE4",backgroundColor:Object(o.x)("#00BDE4",.25)},noteLabel:{marginRight:7,fontWeight:"bold",color:e.text[20]},noteContent:{color:e.text[20]},noteContentLink:{display:"block",margin:"25px 0 15px","& li":{margin:10}},embedCode:{margin:"10px 0 25px"},hasLinkContainer:{marginTop:40,display:"flex",alignItems:"center","& a":{flex:1,display:"flex"},"&:hover svg":{display:"inline-flex"}},hashLinkIcon:{display:"none",margin:"0 10px",fontSize:"3vmin",position:"relative",marginLeft:"calc(-3vmin - 10px)",color:e.palette.secondary.main}}}))},145:function(e,t,n){"use strict";n.d(t,"a",(function(){return a}));var o=n(7),a=Object(o.y)((function(e){return{root:{margin:e.isMobile?10:"25px 75px",width:"100%","& > p":{marginTop:25,lineHeight:1.75,color:e.text["00"]},"& li>p":{marginTop:20,color:e.text["00"]},"& ul > li":{color:e.text["00"]},"& code":{borderRadius:2,padding:"2px 7px",color:e.text["00"],backgroundColor:Object(o.x)("#E4A800",.25)}},divider:{flexShrink:0,backgroundColor:e.text[80]},pageTitle:{fontSize:60,fontWeight:"bold",margin:"25px 0 15px",color:e.text[20],textDecoration:"auto"},contentTitle:{fontSize:35,fontWeight:"bold",color:e.text[20],textDecoration:"auto",borderBottom:"solid 2px ".concat(e.text[50])},contentSubTitle:{fontSize:28,fontWeight:"bold",color:e.text[30],textDecoration:"auto"},codeHeadLabel:{fontSize:20,marginTop:40,fontWeight:"bold",color:e.text[40],textDecoration:"auto"},logo:{width:"90vmin"},logoContract:{height:"60vmin"},codeHeadIcon:{fontSize:22,marginRight:10,color:"#E4A800"},imgWrapper:{display:"flex",backgroundColor:e.background[10]}}}))},147:function(e,t,n){"use strict";n.d(t,"a",(function(){return b}));var o=n(25),a=n(31),s=n(12),c=n(2),i=(n(0),n(144)),r=n(7),d=Object(a.createNode)("NavigationButton",(function(e){var t=e.props,n=e.actions,o=Object(i.a)();return Object(c.jsxs)("div",{className:o.buttonContainer,children:[Object(c.jsxs)("div",{className:o.button,onClick:function(){return n.GOTO_PREVIOUS(t)},style:{alignItems:"flex-end",justifyContent:"flex-start",visibility:t.back?"visible":"hidden"},children:[Object(c.jsx)("div",{className:o.btnSubLabel,style:{},children:"Jump To"}),Object(c.jsxs)("div",{className:o.btnContentWrapper,children:[Object(c.jsx)(r.p,{}),t.back]})]}),Object(c.jsxs)("div",{className:o.button,onClick:function(){return n.GOTO_NEXT(t)},style:{alignItems:"flex-start",justifyContent:"flex-end",visibility:t.next?"visible":"hidden"},children:[Object(c.jsx)("div",{className:o.btnSubLabel,children:"Jump To"}),Object(c.jsxs)("div",{className:o.btnContentWrapper,children:[t.next,Object(c.jsx)(r.q,{})]})]})]})})),l=Object(o.a)(d,2),h=l[0],u=l[1];h.useContract("AppDrawer","GOTO_NEXT",(function(e,t){var n=Object(o.a)(t,1)[0],a=n.next;return n.history.push("/"+a.toLowerCase().replace(/ /g,"-")),{activeSection:a}})),h.useContract("AppDrawer","GOTO_PREVIOUS",(function(e,t){var n=Object(o.a)(t,1)[0],a=n.back;return n.history.push("/"+a.toLowerCase().replace(/ /g,"-")),{activeSection:a}}));var b=Object(s.o)(u(h))},148:function(e,t,n){"use strict";n.d(t,"a",(function(){return r}));var o=n(2),a=(n(0),n(7)),s=n(456),c=n(155),i=n(154),r=function(e){var t=e.isLight,n=e.codeString,r=e.lang,d=Object(a.z)();return Object(o.jsx)(s.a,{language:r,customStyle:{fontSize:17,borderRadius:3,padding:"12px 25px",margin:"10px 0 15px",backgroundColor:t?Object(a.x)(d.text[80],1):d.background[20]},style:t?i.a:c.a,children:n})}},149:function(e,t,n){"use strict";n.d(t,"a",(function(){return s}));var o=n(2),a=(n(0),n(144)),s=function(e){var t=e.content,n=e.type,s=void 0===n?"note":n,c=e.children,i=Object(a.a)();switch(s){case"note":return Object(o.jsxs)("div",{className:i.noteContainer,children:[Object(o.jsx)("span",{className:i.noteLabel,children:"Note:"}),Object(o.jsx)("span",{className:i.noteContent,children:t}),c&&Object(o.jsx)("span",{className:i.noteContentLink,children:c})]});case"attention":return Object(o.jsxs)("div",{className:i.noteContainerAttention,children:[Object(o.jsx)("span",{className:i.noteLabel,children:"Attention:"}),Object(o.jsx)("span",{className:i.noteContent,children:t}),c&&Object(o.jsx)("span",{className:i.noteContentLink,children:c})]});case"info":return Object(o.jsxs)("div",{className:i.noteContainerInfo,children:[Object(o.jsx)("span",{className:i.noteLabel,children:"Info:"}),Object(o.jsx)("span",{className:i.noteContent,children:t}),c&&Object(o.jsx)("span",{className:i.noteContentLink,children:c})]});default:return Object(o.jsxs)("div",{className:i.noteContainer,children:[Object(o.jsx)("span",{className:i.noteLabel,children:"Note:"}),Object(o.jsx)("span",{className:i.noteContent,children:t}),c&&Object(o.jsx)("span",{className:i.noteContentLink,children:c})]})}}},150:function(e,t,n){"use strict";n.d(t,"a",(function(){return p}));var o=n(25),a=n(31),s=n(2),c=n(13);function i(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},s=Object.keys(e);for(o=0;o<s.length;o++)n=s[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(o=0;o<s.length;o++)n=s[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}n(0);var r=n(7),d=n(146),l=n(144),h=Object(a.createNode)("HashLink",(function(e){var t=e.props,n=Object(l.a)(),o=t.children,a=i(t,["children"]),h=window.location.pathname;return Object(s.jsxs)("div",{className:n.hasLinkContainer,children:[Object(s.jsx)(r.j,{className:n.hashLinkIcon}),Object(s.jsx)(d.HashLink,Object(c.a)(Object(c.a)({smooth:!0,to:h+"#"+a.id},a),{},{children:o}))]})})),u=Object(o.a)(h,2),b=u[0],p=(0,u[1])(b)},151:function(e,t,n){"use strict";n.d(t,"a",(function(){return u}));var o=n(25),a=n(31),s=n(2),c=(n(0),n(144)),i=n(146),r=Object(a.createNode)("SelfLink",(function(e){var t=e.props,n=e.actions,o=Object(c.a)();return Object(s.jsx)(i.HashLink,{className:o.link,style:{cursor:"pointer"},to:t.route+"#"+t.id,onClick:function(){return n.NAVIGATE_TO(t)},children:t.name})})),d=Object(o.a)(r,2),l=d[0],h=d[1];l.useContract("AppDrawer","NAVIGATE_TO",(function(e,t){var n=Object(o.a)(t,1)[0],a=n.name,s=(n.route,n.mask);return{activeSection:void 0!==s&&s||a}}));var u=h(l)},153:function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var o=n(2),a=(n(0),n(144));function s(e){var t=Object(a.a)();return Object(o.jsx)("div",{className:t.embedCode,dangerouslySetInnerHTML:{__html:e.iframe?e.iframe:""}})}var c=function(e){var t=e.iFrame;return Object(o.jsx)(s,{iframe:t,allow:"autoplay"})}},157:function(e,t,n){"use strict";n.d(t,"a",(function(){return s}));var o=n(2),a=(n(0),n(144)),s=function(e){var t=e.name,n=e.url,s=Object(a.a)();return Object(o.jsx)("a",{href:n,target:"_blank",rel:"noreferrer",className:s.link,children:t})}},462:function(e,t,n){"use strict";n.r(t);var o=n(25),a=n(31),s=n(2),c=(n(0),n(7)),i=n(148),r=n(149),d=n(157),l=n(150),h=n(151),u=n(147),b=n(145),p=n(153),j="\nconst ADD_TODO = (TodoName) => {\n    return {\n        todos: [\n            ...state.todos,\n            { name: TodoName, completed: false }\n        ]\n    };  \n}\n",m='\nnode.useAction("ADD_TODO", (state, [TodoName]) => {\n    return {\n        todos: [\n            ...state.todos,\n            { name: TodoName, completed: false }\n        ]\n    }\n});\n',x=' \nnode.useAction("ADD_TODO", { \n    name: "Learn Rootz JS", completed: false \n}); \n',f='\nexport const Component = (nodeProps) => {\n    const { state, actions } = nodeProps;\n\n    React.useEffect(() => {\n        fetch("http://mockapi.com/todoapp/todos.json")\n            .then(resp => resp.json())\n            .then(data => {\n                actions.ADD_TODO(data.todos);\n            })\n            .catch(err => {\n                actions.ERROR_FETCHING_TODOS(err);\n            });\n    }, [actions]); \n\n    if(state.hasErrorFetchingTodos) {\n        return <p>error fetching Todos...</p>\n    } else {\n        return { \n            /* CODE_FOR_DISPLAYING_TODOS */ \n        }\n    }\n}\n',g='\nnode.state({ \n    todos: [],\n    hasErrorFetchingTodos: false\n});\n\n// existingTodos would be fetched through API\nnode.useAction("ADD_TODO", (state, [existingTodos]) => {\n    return {\n        todos: [\n            ...state.todos,\n            ...existingTodos\n        ]\n    }\n});\n\n// error fetching todos from API\nnode.useAction("ERROR_FETCHING_TODOS", { \n    hasErrorFetchingTodos: true \n});\n',O="\nexport const Component = (nodeProps) => {\n    const { state, actions } = nodeProps;\n\n    React.useEffect(() => {\n        actions.FETCH_TODOS();\n    }, [actions]); // actions are static and can be added as the dependency.\n\n    if(state.hasErrorFetchingTodos) {\n        return <p>error fetching Todos...</p>\n    } else {\n        return { \n            /* CODE_FOR_DISPLAYING_TODOS */ \n        }\n    }\n}\n",y='\nnode.state({ \n    todos: [],\n    hasErrorFetchingTodos: false\n});\n\n// here the action decides what to be done on success / failure\nnode.useAction("FETCH_TODOS", async (state, args) => {\n    try {\n        const resp = await fetch("http://mockapi.com/todoapp/todos");\n        const data = await resp.json();\n        return { \n            todos: [\n                ...state.todos,\n                ...data.todos\n            ]\n        }\n    } catch {\n        return {\n            hasErrorFetchingTodos: true\n        }\n    }\n});\n',v=Object(a.createNode)("ActionsSection",(function(e){var t=e.props,n=Object(b.a)(),o="light"===t.theme,a='<iframe src="https://codesandbox.io/embed/rootzjs-async-actions-60hqe?fontsize=14&hidenavigation=1&module=%2Fsrc%2Fnodes%2FTodoAsync.js&theme='.concat(t.theme,'"\n    style="width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;"\n    title="rootzjs-async-actions"\n    allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"\n    sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"\n  ></iframe>');return Object(s.jsxs)("div",{className:n.root,children:[Object(s.jsx)("div",{id:"actions",className:n.pageTitle,children:"Actions"}),Object(s.jsxs)(c.w,{variant:"body1",gutterBottom:!0,children:["Actions describe the events occuring in an application. These events serves an intention to interact with the app and request changes. This means change in the existing state of the application. Rootz provides inbuilt ",Object(s.jsx)(h.a,{name:"boilerplate methods",route:"/node",mask:"Node",id:"properties-of-node"})," to create actions, which otherwise had to be created by the user."]}),Object(s.jsx)(c.w,{variant:"body1",gutterBottom:!0,children:"Actions should always return serializable plain objects. These objects are then merged to the existing state, forming a new updated state object. In simple ways actions are the modes of interaction with the application."}),Object(s.jsxs)(c.w,{variant:"body1",gutterBottom:!0,children:["Let's take a look at what actions would look like ",Object(s.jsx)("b",{children:"internally"}),"."]}),Object(s.jsx)(i.a,{lang:"javascript",isLight:o,codeString:j}),Object(s.jsx)(c.w,{variant:"body1",gutterBottom:!0,children:"And this is how you would create one."}),Object(s.jsx)(i.a,{lang:"javascript",isLight:o,codeString:m}),Object(s.jsxs)(c.w,{variant:"body1",gutterBottom:!0,children:["In Rootz you wouldn't need to create the function definition by yourself, rather it provides inbuilt methods to create them. These methods not only help you create functions but also bind them to the ",Object(s.jsx)(h.a,{name:"NodeProps",route:"/nodeprops",id:"accessing-nodeprops"}),"."]}),Object(s.jsxs)(l.a,{id:"actions-as-dependencies-parameter-for-react-effects",className:n.contentSubTitle,children:[Object(s.jsx)("code",{children:"actions"})," as dependency parameter for ",Object(s.jsx)("code",{children:"React Effects"})]}),Object(s.jsxs)(c.w,{variant:"body1",gutterBottom:!0,children:["Actions are static by nature. That is, they do not provide a new functional reference (pointer in memory) each time the component renders. This provides boost in performance as they are not re-created on every render. ",Object(s.jsx)("code",{children:"actions"})," within a component can be used as dependency for ",Object(s.jsx)(d.a,{name:"React Effects",url:"https://reactjs.org/docs/hooks-effect.html"}),". "]}),Object(s.jsx)(r.a,{content:'"Non-static functions cannot be a part of the useEffect dependency list. This would result in infinite loop re-rendering the component over and over agin. A function is a new function reference (pointer in memory) each time the component renders. By this useEffect gets triggers the re-render because of the dependency. Checkout the react documentation for using "useEffect". For non-static functions you could rather use "React.useCallback" hook to memoize the function called within useEffect. For more info on useCallback refer:',type:"info",children:Object(s.jsxs)("ul",{children:[Object(s.jsx)("li",{children:Object(s.jsx)(d.a,{name:"React Documentation on useEffect",url:"https://reactjs.org/docs/hooks-reference.html#conditionally-firing-an-effect"})}),Object(s.jsx)("li",{children:Object(s.jsx)(d.a,{name:"how to read an often changing value from useCallback",url:"https://reactjs.org/docs/hooks-faq.html#how-to-read-an-often-changing-value-from-usecallback"})})]})}),Object(s.jsx)(l.a,{id:"create-actions",className:n.contentTitle,children:"Create Actions"}),Object(s.jsxs)(c.w,{variant:"body1",gutterBottom:!0,children:["Some frameworks like ",Object(s.jsx)(d.a,{name:"Redux",route:"https://redux.js.org"})," allow users to explicitly define actions and reducers. Such solutions still generate redundant code and too much boilerplate to follow even for a simple state update. Under the hood this is handled by keeping things simple, by ",Object(s.jsx)(h.a,{name:"Actions",route:"/Node",id:"node-useaction"}),". Although ",Object(s.jsx)("b",{children:"Actions"})," are created implicitly, you get complete control over its logical definition. It not only provides standalone functionality, but also binds them to ",Object(s.jsx)(h.a,{name:"NodeProps",route:"/nodeprops",id:"accessing-nodeprops"})," without explicitly defining its mappings."]}),Object(s.jsxs)(c.w,{variant:"body1",gutterBottom:!0,children:["There are two approaches to create them, ",Object(s.jsx)("code",{children:"node.useAction"})," and ",Object(s.jsx)("code",{children:"node.useActionCallback"}),". They both serve different purposes, incase if you want to update the state without any prior conditions you could use ",Object(s.jsx)(h.a,{name:"node.useActions",route:"/node",mask:"Node",id:"node-useaction"}),". This are ",Object(s.jsx)("b",{children:"Pure Actions"}),". In case if condition arises where you need to generate the state based on inputs, you could use ",Object(s.jsx)(h.a,{name:"node.useActionsCallback",route:"/node",mask:"Node",id:"node-useactioncallback"}),". This allows you to access the ",Object(s.jsx)("code",{children:"state"})," variables and conditional parameters as arguments. These actions are called ",Object(s.jsx)("b",{children:"Actions with update logic"}),"."]}),Object(s.jsx)(r.a,{content:"useActionCallback allows you to describe the update logic. You can access the current state of the Node as well as pass arguments for computing."}),Object(s.jsx)(l.a,{id:"pure-actions",className:n.contentSubTitle,children:"Pure Actions"}),Object(s.jsx)(i.a,{lang:"javascript",isLight:o,codeString:x}),Object(s.jsx)(c.w,{variant:"body1",gutterBottom:!0,children:"One with actions logic would appear like this."}),Object(s.jsx)(l.a,{id:"actions-with-update-logic",className:n.contentSubTitle,children:"Actions with update logic"}),Object(s.jsx)(i.a,{lang:"javascript",isLight:o,codeString:m}),Object(s.jsxs)(c.w,{variant:"body1",gutterBottom:!0,children:["In the above example ",Object(s.jsx)("code",{children:"state"})," is predefined as the first argument variable. While the parameters sent would result as an constructed array in the second argument, ",Object(s.jsx)("code",{children:"TodoName"}),". This provides "]}),Object(s.jsx)(r.a,{content:"state, represents the current state of the Node. For example if the state of the Node is updated earlier, you would get the updated state as the argument."}),Object(s.jsx)(l.a,{id:"create-async-actions",className:n.contentTitle,children:"Create Async Actions"}),Object(s.jsxs)(c.w,{variant:"body1",gutterBottom:!0,children:["In scenarios where ",Object(s.jsx)(h.a,{name:"async state update",route:"/go-async",mask:"Go Async"})," is required, the procedure in creating an action would remain the same. The only change required would be during its call. In such scenario the action would be called inside the promise."]}),Object(s.jsx)(c.w,{variant:"body1",gutterBottom:!0,children:"Let's take an example of async state update."}),Object(s.jsx)("div",{className:n.codeHeadLabel,children:"components/AddTodoAsync.js"}),Object(s.jsx)(i.a,{lang:"javascript",isLight:o,codeString:f}),Object(s.jsx)(c.w,{variant:"body1",gutterBottom:!0,children:"Here the format of creating and calling an action remains the same. Only for async state update, actions are called within a promise. "}),Object(s.jsx)("div",{className:n.codeHeadLabel,children:"nodes/AddTodoAsync.jsx"}),Object(s.jsx)(i.a,{lang:"javascript",isLight:o,codeString:g}),Object(s.jsxs)(c.w,{variant:"body1",gutterBottom:!0,children:["In this case the ",Object(s.jsx)("code",{children:"Actions"})," are kept pure, letting the component decide which action to be called on success / failure. There is another way you could approach the same problem by adding an ",Object(s.jsx)("code",{children:"async"})," call within an action itself. ",Object(s.jsx)("b",{children:"Actions with Async dependency"}),"."]}),Object(s.jsx)(r.a,{content:'node.useActionCallback supports asynchronous callbacks. This helps implementing "call and forget" nature for components.'}),Object(s.jsxs)(l.a,{id:"actions-with-async-dependencies",className:n.contentTitle,children:["Actions with ",Object(s.jsx)("code",{children:"Async Dependency"})]}),Object(s.jsxs)(c.w,{variant:"body1",gutterBottom:!0,children:["This freedom of updating logic within an action, lets us write more ",Object(s.jsx)("b",{children:"expressive async functions"}),". Where adding the API requests within an action ",Object(s.jsx)("b",{children:"inverts the control from component to node"}),". This results in ",Object(s.jsx)("b",{children:"call and forget"})," nature for a component. In this case the component wouldn't have to worry about it state update, the action would take care of it."]}),Object(s.jsx)(r.a,{content:"Either of this approach will provide same result. We still recommend you to use the later one for moving its dependency from the component. As all of its dependencies are handled by the node.",type:"info"}),Object(s.jsx)(c.w,{variant:"body1",gutterBottom:!0,children:"Let's take the same example to understand this."}),Object(s.jsx)("div",{className:n.codeHeadLabel,children:"components/TodoAsync.js"}),Object(s.jsx)(i.a,{lang:"javascript",isLight:o,codeString:O}),Object(s.jsx)("div",{className:n.codeHeadLabel,children:"nodes/TodoAsync.jsx"}),Object(s.jsx)(i.a,{lang:"javascript",isLight:o,codeString:y}),Object(s.jsx)("div",{className:n.codeHeadLabel,children:"Try it out..."}),Object(s.jsx)(p.a,{iFrame:a}),Object(s.jsx)(c.w,{variant:"body1",gutterBottom:!0,children:"It not only shifts the dependency on Node but also handle success / failure within the same action. This helps you to add specific behavior when you update the state."}),Object(s.jsxs)(c.w,{variant:"body1",gutterBottom:!0,children:["This is much less typing! You can still use a ",Object(s.jsx)("code",{children:".then()"})," ",Object(s.jsx)("b",{children:"chaining"})," over ",Object(s.jsx)("code",{children:"async await"}),". The later makes the code more readable, maintainable and easier to understand and test. It's purely a personal choice."]}),Object(s.jsx)(u.a,{back:"State",next:"Contract"})]})})),w=Object(o.a)(v,2),T=w[0],k=w[1];t.default=k(T)}}]);
//# sourceMappingURL=5.d76fc7ec.chunk.js.map